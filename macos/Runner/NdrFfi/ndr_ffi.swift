// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(ndr_ffiFFI)
import ndr_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_ndr_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_ndr_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * FFI wrapper for Invite.
 */
public protocol InviteHandleProtocol : AnyObject {
    
    /**
     * Accept the invite and create a session.
     */
    func accept(inviteePubkeyHex: String, inviteePrivkeyHex: String, deviceId: String?) throws  -> InviteAcceptResult
    
    /**
     * Accept the invite as an owner and include the owner pubkey in the response payload.
     */
    func acceptWithOwner(inviteePubkeyHex: String, inviteePrivkeyHex: String, deviceId: String?, ownerPubkeyHex: String?) throws  -> InviteAcceptResult
    
    /**
     * Get the inviter's public key as hex.
     */
    func getInviterPubkeyHex()  -> String
    
    /**
     * Get the shared secret as hex.
     */
    func getSharedSecretHex()  -> String
    
    /**
     * Process an invite response event and create a session (inviter side).
     *
     * Returns `None` if the event is not a valid response for this invite.
     */
    func processResponse(eventJson: String, inviterPrivkeyHex: String) throws  -> InviteProcessResult?
    
    /**
     * Serialize the invite to JSON for persistence.
     */
    func serialize() throws  -> String
    
    /**
     * Update the owner pubkey embedded in invite URLs.
     */
    func setOwnerPubkeyHex(ownerPubkeyHex: String?) throws 
    
    /**
     * Update the invite purpose (e.g. \"link\").
     */
    func setPurpose(purpose: String?) 
    
    /**
     * Convert the invite to a Nostr event JSON.
     */
    func toEventJson() throws  -> String
    
    /**
     * Convert the invite to a shareable URL.
     */
    func toUrl(root: String) throws  -> String
    
}

/**
 * FFI wrapper for Invite.
 */
open class InviteHandle:
    InviteHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ndr_ffi_fn_clone_invitehandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ndr_ffi_fn_free_invitehandle(pointer, $0) }
    }

    
    /**
     * Create a new invite.
     */
public static func createNew(inviterPubkeyHex: String, deviceId: String?, maxUses: UInt32?)throws  -> InviteHandle {
    return try  FfiConverterTypeInviteHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_invitehandle_create_new(
        FfiConverterString.lower(inviterPubkeyHex),
        FfiConverterOptionString.lower(deviceId),
        FfiConverterOptionUInt32.lower(maxUses),$0
    )
})
}
    
    /**
     * Deserialize an invite from JSON.
     */
public static func deserialize(json: String)throws  -> InviteHandle {
    return try  FfiConverterTypeInviteHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_invitehandle_deserialize(
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Parse an invite from a Nostr event JSON.
     */
public static func fromEventJson(eventJson: String)throws  -> InviteHandle {
    return try  FfiConverterTypeInviteHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_invitehandle_from_event_json(
        FfiConverterString.lower(eventJson),$0
    )
})
}
    
    /**
     * Parse an invite from a URL.
     */
public static func fromUrl(url: String)throws  -> InviteHandle {
    return try  FfiConverterTypeInviteHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_invitehandle_from_url(
        FfiConverterString.lower(url),$0
    )
})
}
    

    
    /**
     * Accept the invite and create a session.
     */
open func accept(inviteePubkeyHex: String, inviteePrivkeyHex: String, deviceId: String?)throws  -> InviteAcceptResult {
    return try  FfiConverterTypeInviteAcceptResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_accept(self.uniffiClonePointer(),
        FfiConverterString.lower(inviteePubkeyHex),
        FfiConverterString.lower(inviteePrivkeyHex),
        FfiConverterOptionString.lower(deviceId),$0
    )
})
}
    
    /**
     * Accept the invite as an owner and include the owner pubkey in the response payload.
     */
open func acceptWithOwner(inviteePubkeyHex: String, inviteePrivkeyHex: String, deviceId: String?, ownerPubkeyHex: String?)throws  -> InviteAcceptResult {
    return try  FfiConverterTypeInviteAcceptResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_accept_with_owner(self.uniffiClonePointer(),
        FfiConverterString.lower(inviteePubkeyHex),
        FfiConverterString.lower(inviteePrivkeyHex),
        FfiConverterOptionString.lower(deviceId),
        FfiConverterOptionString.lower(ownerPubkeyHex),$0
    )
})
}
    
    /**
     * Get the inviter's public key as hex.
     */
open func getInviterPubkeyHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_invitehandle_get_inviter_pubkey_hex(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the shared secret as hex.
     */
open func getSharedSecretHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_invitehandle_get_shared_secret_hex(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Process an invite response event and create a session (inviter side).
     *
     * Returns `None` if the event is not a valid response for this invite.
     */
open func processResponse(eventJson: String, inviterPrivkeyHex: String)throws  -> InviteProcessResult? {
    return try  FfiConverterOptionTypeInviteProcessResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_process_response(self.uniffiClonePointer(),
        FfiConverterString.lower(eventJson),
        FfiConverterString.lower(inviterPrivkeyHex),$0
    )
})
}
    
    /**
     * Serialize the invite to JSON for persistence.
     */
open func serialize()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_serialize(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Update the owner pubkey embedded in invite URLs.
     */
open func setOwnerPubkeyHex(ownerPubkeyHex: String?)throws  {try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_set_owner_pubkey_hex(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(ownerPubkeyHex),$0
    )
}
}
    
    /**
     * Update the invite purpose (e.g. \"link\").
     */
open func setPurpose(purpose: String?) {try! rustCall() {
    uniffi_ndr_ffi_fn_method_invitehandle_set_purpose(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(purpose),$0
    )
}
}
    
    /**
     * Convert the invite to a Nostr event JSON.
     */
open func toEventJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_to_event_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Convert the invite to a shareable URL.
     */
open func toUrl(root: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_invitehandle_to_url(self.uniffiClonePointer(),
        FfiConverterString.lower(root),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInviteHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InviteHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InviteHandle {
        return InviteHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InviteHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InviteHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InviteHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> InviteHandle {
    return try FfiConverterTypeInviteHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteHandle_lower(_ value: InviteHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInviteHandle.lower(value)
}




/**
 * FFI wrapper for Session.
 */
public protocol SessionHandleProtocol : AnyObject {
    
    /**
     * Check if the session is ready to send messages.
     */
    func canSend()  -> Bool
    
    /**
     * Decrypt a received event.
     */
    func decryptEvent(outerEventJson: String) throws  -> DecryptResult
    
    /**
     * Check if an event is a double-ratchet message.
     */
    func isDrMessage(eventJson: String)  -> Bool
    
    /**
     * Send a text message.
     */
    func sendText(text: String) throws  -> SendResult
    
    /**
     * Serialize the session state to JSON.
     */
    func stateJson() throws  -> String
    
}

/**
 * FFI wrapper for Session.
 */
open class SessionHandle:
    SessionHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ndr_ffi_fn_clone_sessionhandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ndr_ffi_fn_free_sessionhandle(pointer, $0) }
    }

    
    /**
     * Restore a session from serialized state JSON.
     */
public static func fromStateJson(stateJson: String)throws  -> SessionHandle {
    return try  FfiConverterTypeSessionHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_sessionhandle_from_state_json(
        FfiConverterString.lower(stateJson),$0
    )
})
}
    
    /**
     * Initialize a new session.
     */
public static func `init`(theirEphemeralPubkeyHex: String, ourEphemeralPrivkeyHex: String, isInitiator: Bool, sharedSecretHex: String, name: String?)throws  -> SessionHandle {
    return try  FfiConverterTypeSessionHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_sessionhandle_init(
        FfiConverterString.lower(theirEphemeralPubkeyHex),
        FfiConverterString.lower(ourEphemeralPrivkeyHex),
        FfiConverterBool.lower(isInitiator),
        FfiConverterString.lower(sharedSecretHex),
        FfiConverterOptionString.lower(name),$0
    )
})
}
    

    
    /**
     * Check if the session is ready to send messages.
     */
open func canSend() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionhandle_can_send(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Decrypt a received event.
     */
open func decryptEvent(outerEventJson: String)throws  -> DecryptResult {
    return try  FfiConverterTypeDecryptResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionhandle_decrypt_event(self.uniffiClonePointer(),
        FfiConverterString.lower(outerEventJson),$0
    )
})
}
    
    /**
     * Check if an event is a double-ratchet message.
     */
open func isDrMessage(eventJson: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionhandle_is_dr_message(self.uniffiClonePointer(),
        FfiConverterString.lower(eventJson),$0
    )
})
}
    
    /**
     * Send a text message.
     */
open func sendText(text: String)throws  -> SendResult {
    return try  FfiConverterTypeSendResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionhandle_send_text(self.uniffiClonePointer(),
        FfiConverterString.lower(text),$0
    )
})
}
    
    /**
     * Serialize the session state to JSON.
     */
open func stateJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionhandle_state_json(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionHandle {
        return SessionHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionHandle {
    return try FfiConverterTypeSessionHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionHandle_lower(_ value: SessionHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionHandle.lower(value)
}




/**
 * FFI wrapper for SessionManager.
 */
public protocol SessionManagerHandleProtocol : AnyObject {
    
    /**
     * Accept an invite event JSON using SessionManager's owner-aware routing/auth checks.
     */
    func acceptInviteFromEventJson(eventJson: String, ownerPubkeyHintHex: String?) throws  -> SessionManagerAcceptInviteResult
    
    /**
     * Accept an invite URL using SessionManager's owner-aware routing/auth checks.
     *
     * This flow also emits the signed invite response via SessionManager pubsub events,
     * so hosts should continue draining and publishing `publish_signed` events.
     */
    func acceptInviteFromUrl(inviteUrl: String, ownerPubkeyHintHex: String?) throws  -> SessionManagerAcceptInviteResult
    
    /**
     * Drain pending pubsub events from the internal queue.
     */
    func drainEvents() throws  -> [PubSubEvent]
    
    /**
     * Export the active session state for a peer.
     */
    func getActiveSessionState(peerPubkeyHex: String) throws  -> String?
    
    /**
     * Get our device id.
     */
    func getDeviceId()  -> String
    
    /**
     * Get our public key as hex.
     */
    func getOurPubkeyHex()  -> String
    
    /**
     * Get owner public key as hex.
     */
    func getOwnerPubkeyHex()  -> String
    
    /**
     * Get total active sessions.
     */
    func getTotalSessions()  -> UInt64
    
    /**
     * Handle a decrypted pairwise session rumor that may carry sender-key distribution.
     */
    func groupHandleIncomingSessionEvent(eventJson: String, fromOwnerPubkeyHex: String, fromSenderDevicePubkeyHex: String?) throws  -> [GroupDecryptedResult]
    
    /**
     * Handle an incoming relay event that may be an encrypted one-to-many group outer event.
     */
    func groupHandleOuterEvent(eventJson: String) throws  -> GroupDecryptedResult?
    
    /**
     * Return known sender-event pubkeys used for one-to-many group transport.
     */
    func groupKnownSenderEventPubkeys()  -> [String]
    
    /**
     * Remove a group from the embedded GroupManager.
     */
    func groupRemove(groupId: String) 
    
    /**
     * Send a group event through GroupManager.
     *
     * Pairwise sender-key distribution rumors are sent through SessionManager sessions.
     * The encrypted one-to-many outer event is emitted via the SessionManager pubsub queue.
     */
    func groupSendEvent(groupId: String, kind: UInt32, content: String, tagsJson: String, nowMs: UInt64?) throws  -> GroupSendResult
    
    /**
     * Upsert group metadata into the embedded GroupManager.
     */
    func groupUpsert(group: FfiGroupData) throws 
    
    /**
     * Import a session state for a peer.
     */
    func importSessionState(peerPubkeyHex: String, stateJson: String, deviceId: String?) throws 
    
    /**
     * Initialize the session manager (loads state, creates device invite, subscribes).
     */
    func `init`() throws 
    
    /**
     * Process a received Nostr event JSON.
     */
    func processEvent(eventJson: String) throws 
    
    /**
     * Send an arbitrary inner rumor event to a recipient, returning stable inner id + outer ids.
     *
     * This is used for group chats where we need custom kinds/tags (e.g. group metadata kind 40,
     * group-tagged chat messages kind 14, reactions kind 7, typing kind 25).
     *
     * The caller controls the inner rumor tags via `tags_json` (JSON array of string arrays).
     * For group fan-out, do NOT include recipient-specific tags like `["p", <recipient>]` so
     * the inner rumor id stays stable across all recipients.
     */
    func sendEventWithInnerId(recipientPubkeyHex: String, kind: UInt32, content: String, tagsJson: String, createdAtSeconds: UInt64?) throws  -> SendTextResult
    
    /**
     * Send an emoji reaction (kind 7) to a specific message id.
     */
    func sendReaction(recipientPubkeyHex: String, messageId: String, emoji: String, expiresAtSeconds: UInt64?) throws  -> [String]
    
    /**
     * Send a delivery/read receipt for messages.
     */
    func sendReceipt(recipientPubkeyHex: String, receiptType: String, messageIds: [String], expiresAtSeconds: UInt64?) throws  -> [String]
    
    /**
     * Send a text message to a recipient.
     */
    func sendText(recipientPubkeyHex: String, text: String, expiresAtSeconds: UInt64?) throws  -> [String]
    
    /**
     * Send a text message and return both the stable inner (rumor) id and the
     * list of outer message event ids that were published.
     */
    func sendTextWithInnerId(recipientPubkeyHex: String, text: String, expiresAtSeconds: UInt64?) throws  -> SendTextResult
    
    /**
     * Send a typing indicator.
     */
    func sendTyping(recipientPubkeyHex: String, expiresAtSeconds: UInt64?) throws  -> [String]
    
}

/**
 * FFI wrapper for SessionManager.
 */
open class SessionManagerHandle:
    SessionManagerHandleProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ndr_ffi_fn_clone_sessionmanagerhandle(self.pointer, $0) }
    }
    /**
     * Create a new session manager with an internal event queue.
     */
public convenience init(ourPubkeyHex: String, ourIdentityPrivkeyHex: String, deviceId: String, ownerPubkeyHex: String?)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_sessionmanagerhandle_new(
        FfiConverterString.lower(ourPubkeyHex),
        FfiConverterString.lower(ourIdentityPrivkeyHex),
        FfiConverterString.lower(deviceId),
        FfiConverterOptionString.lower(ownerPubkeyHex),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ndr_ffi_fn_free_sessionmanagerhandle(pointer, $0) }
    }

    
    /**
     * Create a new session manager with file-backed storage.
     */
public static func newWithStoragePath(ourPubkeyHex: String, ourIdentityPrivkeyHex: String, deviceId: String, storagePath: String, ownerPubkeyHex: String?)throws  -> SessionManagerHandle {
    return try  FfiConverterTypeSessionManagerHandle.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_constructor_sessionmanagerhandle_new_with_storage_path(
        FfiConverterString.lower(ourPubkeyHex),
        FfiConverterString.lower(ourIdentityPrivkeyHex),
        FfiConverterString.lower(deviceId),
        FfiConverterString.lower(storagePath),
        FfiConverterOptionString.lower(ownerPubkeyHex),$0
    )
})
}
    

    
    /**
     * Accept an invite event JSON using SessionManager's owner-aware routing/auth checks.
     */
open func acceptInviteFromEventJson(eventJson: String, ownerPubkeyHintHex: String?)throws  -> SessionManagerAcceptInviteResult {
    return try  FfiConverterTypeSessionManagerAcceptInviteResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_accept_invite_from_event_json(self.uniffiClonePointer(),
        FfiConverterString.lower(eventJson),
        FfiConverterOptionString.lower(ownerPubkeyHintHex),$0
    )
})
}
    
    /**
     * Accept an invite URL using SessionManager's owner-aware routing/auth checks.
     *
     * This flow also emits the signed invite response via SessionManager pubsub events,
     * so hosts should continue draining and publishing `publish_signed` events.
     */
open func acceptInviteFromUrl(inviteUrl: String, ownerPubkeyHintHex: String?)throws  -> SessionManagerAcceptInviteResult {
    return try  FfiConverterTypeSessionManagerAcceptInviteResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_accept_invite_from_url(self.uniffiClonePointer(),
        FfiConverterString.lower(inviteUrl),
        FfiConverterOptionString.lower(ownerPubkeyHintHex),$0
    )
})
}
    
    /**
     * Drain pending pubsub events from the internal queue.
     */
open func drainEvents()throws  -> [PubSubEvent] {
    return try  FfiConverterSequenceTypePubSubEvent.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_drain_events(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Export the active session state for a peer.
     */
open func getActiveSessionState(peerPubkeyHex: String)throws  -> String? {
    return try  FfiConverterOptionString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_get_active_session_state(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkeyHex),$0
    )
})
}
    
    /**
     * Get our device id.
     */
open func getDeviceId() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_get_device_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get our public key as hex.
     */
open func getOurPubkeyHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_get_our_pubkey_hex(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get owner public key as hex.
     */
open func getOwnerPubkeyHex() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_get_owner_pubkey_hex(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get total active sessions.
     */
open func getTotalSessions() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_get_total_sessions(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Handle a decrypted pairwise session rumor that may carry sender-key distribution.
     */
open func groupHandleIncomingSessionEvent(eventJson: String, fromOwnerPubkeyHex: String, fromSenderDevicePubkeyHex: String?)throws  -> [GroupDecryptedResult] {
    return try  FfiConverterSequenceTypeGroupDecryptedResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_group_handle_incoming_session_event(self.uniffiClonePointer(),
        FfiConverterString.lower(eventJson),
        FfiConverterString.lower(fromOwnerPubkeyHex),
        FfiConverterOptionString.lower(fromSenderDevicePubkeyHex),$0
    )
})
}
    
    /**
     * Handle an incoming relay event that may be an encrypted one-to-many group outer event.
     */
open func groupHandleOuterEvent(eventJson: String)throws  -> GroupDecryptedResult? {
    return try  FfiConverterOptionTypeGroupDecryptedResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_group_handle_outer_event(self.uniffiClonePointer(),
        FfiConverterString.lower(eventJson),$0
    )
})
}
    
    /**
     * Return known sender-event pubkeys used for one-to-many group transport.
     */
open func groupKnownSenderEventPubkeys() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_group_known_sender_event_pubkeys(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Remove a group from the embedded GroupManager.
     */
open func groupRemove(groupId: String) {try! rustCall() {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_group_remove(self.uniffiClonePointer(),
        FfiConverterString.lower(groupId),$0
    )
}
}
    
    /**
     * Send a group event through GroupManager.
     *
     * Pairwise sender-key distribution rumors are sent through SessionManager sessions.
     * The encrypted one-to-many outer event is emitted via the SessionManager pubsub queue.
     */
open func groupSendEvent(groupId: String, kind: UInt32, content: String, tagsJson: String, nowMs: UInt64?)throws  -> GroupSendResult {
    return try  FfiConverterTypeGroupSendResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_group_send_event(self.uniffiClonePointer(),
        FfiConverterString.lower(groupId),
        FfiConverterUInt32.lower(kind),
        FfiConverterString.lower(content),
        FfiConverterString.lower(tagsJson),
        FfiConverterOptionUInt64.lower(nowMs),$0
    )
})
}
    
    /**
     * Upsert group metadata into the embedded GroupManager.
     */
open func groupUpsert(group: FfiGroupData)throws  {try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_group_upsert(self.uniffiClonePointer(),
        FfiConverterTypeFfiGroupData.lower(group),$0
    )
}
}
    
    /**
     * Import a session state for a peer.
     */
open func importSessionState(peerPubkeyHex: String, stateJson: String, deviceId: String?)throws  {try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_import_session_state(self.uniffiClonePointer(),
        FfiConverterString.lower(peerPubkeyHex),
        FfiConverterString.lower(stateJson),
        FfiConverterOptionString.lower(deviceId),$0
    )
}
}
    
    /**
     * Initialize the session manager (loads state, creates device invite, subscribes).
     */
open func `init`()throws  {try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_init(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Process a received Nostr event JSON.
     */
open func processEvent(eventJson: String)throws  {try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_process_event(self.uniffiClonePointer(),
        FfiConverterString.lower(eventJson),$0
    )
}
}
    
    /**
     * Send an arbitrary inner rumor event to a recipient, returning stable inner id + outer ids.
     *
     * This is used for group chats where we need custom kinds/tags (e.g. group metadata kind 40,
     * group-tagged chat messages kind 14, reactions kind 7, typing kind 25).
     *
     * The caller controls the inner rumor tags via `tags_json` (JSON array of string arrays).
     * For group fan-out, do NOT include recipient-specific tags like `["p", <recipient>]` so
     * the inner rumor id stays stable across all recipients.
     */
open func sendEventWithInnerId(recipientPubkeyHex: String, kind: UInt32, content: String, tagsJson: String, createdAtSeconds: UInt64?)throws  -> SendTextResult {
    return try  FfiConverterTypeSendTextResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_send_event_with_inner_id(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPubkeyHex),
        FfiConverterUInt32.lower(kind),
        FfiConverterString.lower(content),
        FfiConverterString.lower(tagsJson),
        FfiConverterOptionUInt64.lower(createdAtSeconds),$0
    )
})
}
    
    /**
     * Send an emoji reaction (kind 7) to a specific message id.
     */
open func sendReaction(recipientPubkeyHex: String, messageId: String, emoji: String, expiresAtSeconds: UInt64?)throws  -> [String] {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_send_reaction(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPubkeyHex),
        FfiConverterString.lower(messageId),
        FfiConverterString.lower(emoji),
        FfiConverterOptionUInt64.lower(expiresAtSeconds),$0
    )
})
}
    
    /**
     * Send a delivery/read receipt for messages.
     */
open func sendReceipt(recipientPubkeyHex: String, receiptType: String, messageIds: [String], expiresAtSeconds: UInt64?)throws  -> [String] {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_send_receipt(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPubkeyHex),
        FfiConverterString.lower(receiptType),
        FfiConverterSequenceString.lower(messageIds),
        FfiConverterOptionUInt64.lower(expiresAtSeconds),$0
    )
})
}
    
    /**
     * Send a text message to a recipient.
     */
open func sendText(recipientPubkeyHex: String, text: String, expiresAtSeconds: UInt64?)throws  -> [String] {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_send_text(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPubkeyHex),
        FfiConverterString.lower(text),
        FfiConverterOptionUInt64.lower(expiresAtSeconds),$0
    )
})
}
    
    /**
     * Send a text message and return both the stable inner (rumor) id and the
     * list of outer message event ids that were published.
     */
open func sendTextWithInnerId(recipientPubkeyHex: String, text: String, expiresAtSeconds: UInt64?)throws  -> SendTextResult {
    return try  FfiConverterTypeSendTextResult.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_send_text_with_inner_id(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPubkeyHex),
        FfiConverterString.lower(text),
        FfiConverterOptionUInt64.lower(expiresAtSeconds),$0
    )
})
}
    
    /**
     * Send a typing indicator.
     */
open func sendTyping(recipientPubkeyHex: String, expiresAtSeconds: UInt64?)throws  -> [String] {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_method_sessionmanagerhandle_send_typing(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPubkeyHex),
        FfiConverterOptionUInt64.lower(expiresAtSeconds),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionManagerHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SessionManagerHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionManagerHandle {
        return SessionManagerHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SessionManagerHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionManagerHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SessionManagerHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionManagerHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> SessionManagerHandle {
    return try FfiConverterTypeSessionManagerHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionManagerHandle_lower(_ value: SessionManagerHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSessionManagerHandle.lower(value)
}


/**
 * Result of decrypting a message.
 */
public struct DecryptResult {
    public var plaintext: String
    public var innerEventJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plaintext: String, innerEventJson: String) {
        self.plaintext = plaintext
        self.innerEventJson = innerEventJson
    }
}



extension DecryptResult: Equatable, Hashable {
    public static func ==(lhs: DecryptResult, rhs: DecryptResult) -> Bool {
        if lhs.plaintext != rhs.plaintext {
            return false
        }
        if lhs.innerEventJson != rhs.innerEventJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plaintext)
        hasher.combine(innerEventJson)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecryptResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptResult {
        return
            try DecryptResult(
                plaintext: FfiConverterString.read(from: &buf), 
                innerEventJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DecryptResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.plaintext, into: &buf)
        FfiConverterString.write(value.innerEventJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecryptResult_lift(_ buf: RustBuffer) throws -> DecryptResult {
    return try FfiConverterTypeDecryptResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecryptResult_lower(_ value: DecryptResult) -> RustBuffer {
    return FfiConverterTypeDecryptResult.lower(value)
}


/**
 * FFI-friendly device entry for AppKeys.
 */
public struct FfiDeviceEntry {
    public var identityPubkeyHex: String
    public var createdAt: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityPubkeyHex: String, createdAt: UInt64) {
        self.identityPubkeyHex = identityPubkeyHex
        self.createdAt = createdAt
    }
}



extension FfiDeviceEntry: Equatable, Hashable {
    public static func ==(lhs: FfiDeviceEntry, rhs: FfiDeviceEntry) -> Bool {
        if lhs.identityPubkeyHex != rhs.identityPubkeyHex {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityPubkeyHex)
        hasher.combine(createdAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiDeviceEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeviceEntry {
        return
            try FfiDeviceEntry(
                identityPubkeyHex: FfiConverterString.read(from: &buf), 
                createdAt: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiDeviceEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identityPubkeyHex, into: &buf)
        FfiConverterUInt64.write(value.createdAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeviceEntry_lift(_ buf: RustBuffer) throws -> FfiDeviceEntry {
    return try FfiConverterTypeFfiDeviceEntry.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiDeviceEntry_lower(_ value: FfiDeviceEntry) -> RustBuffer {
    return FfiConverterTypeFfiDeviceEntry.lower(value)
}


/**
 * FFI-friendly group metadata payload.
 */
public struct FfiGroupData {
    public var id: String
    public var name: String
    public var description: String?
    public var picture: String?
    public var members: [String]
    public var admins: [String]
    public var createdAtMs: UInt64
    public var secret: String?
    public var accepted: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, description: String?, picture: String?, members: [String], admins: [String], createdAtMs: UInt64, secret: String?, accepted: Bool?) {
        self.id = id
        self.name = name
        self.description = description
        self.picture = picture
        self.members = members
        self.admins = admins
        self.createdAtMs = createdAtMs
        self.secret = secret
        self.accepted = accepted
    }
}



extension FfiGroupData: Equatable, Hashable {
    public static func ==(lhs: FfiGroupData, rhs: FfiGroupData) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.picture != rhs.picture {
            return false
        }
        if lhs.members != rhs.members {
            return false
        }
        if lhs.admins != rhs.admins {
            return false
        }
        if lhs.createdAtMs != rhs.createdAtMs {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.accepted != rhs.accepted {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(picture)
        hasher.combine(members)
        hasher.combine(admins)
        hasher.combine(createdAtMs)
        hasher.combine(secret)
        hasher.combine(accepted)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGroupData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupData {
        return
            try FfiGroupData(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                picture: FfiConverterOptionString.read(from: &buf), 
                members: FfiConverterSequenceString.read(from: &buf), 
                admins: FfiConverterSequenceString.read(from: &buf), 
                createdAtMs: FfiConverterUInt64.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf), 
                accepted: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGroupData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.picture, into: &buf)
        FfiConverterSequenceString.write(value.members, into: &buf)
        FfiConverterSequenceString.write(value.admins, into: &buf)
        FfiConverterUInt64.write(value.createdAtMs, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
        FfiConverterOptionBool.write(value.accepted, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupData_lift(_ buf: RustBuffer) throws -> FfiGroupData {
    return try FfiConverterTypeFfiGroupData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGroupData_lower(_ value: FfiGroupData) -> RustBuffer {
    return FfiConverterTypeFfiGroupData.lower(value)
}


/**
 * FFI-friendly keypair with hex-encoded keys.
 */
public struct FfiKeyPair {
    public var publicKeyHex: String
    public var privateKeyHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKeyHex: String, privateKeyHex: String) {
        self.publicKeyHex = publicKeyHex
        self.privateKeyHex = privateKeyHex
    }
}



extension FfiKeyPair: Equatable, Hashable {
    public static func ==(lhs: FfiKeyPair, rhs: FfiKeyPair) -> Bool {
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.privateKeyHex != rhs.privateKeyHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKeyHex)
        hasher.combine(privateKeyHex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiKeyPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiKeyPair {
        return
            try FfiKeyPair(
                publicKeyHex: FfiConverterString.read(from: &buf), 
                privateKeyHex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiKeyPair, into buf: inout [UInt8]) {
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.privateKeyHex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyPair_lift(_ buf: RustBuffer) throws -> FfiKeyPair {
    return try FfiConverterTypeFfiKeyPair.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiKeyPair_lower(_ value: FfiKeyPair) -> RustBuffer {
    return FfiConverterTypeFfiKeyPair.lower(value)
}


/**
 * Decrypted group event returned by GroupManager.
 */
public struct GroupDecryptedResult {
    public var groupId: String
    public var senderEventPubkeyHex: String
    public var senderDevicePubkeyHex: String
    public var senderOwnerPubkeyHex: String?
    public var outerEventId: String
    public var outerCreatedAt: UInt64
    public var keyId: UInt32
    public var messageNumber: UInt32
    public var innerEventJson: String
    public var innerEventId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(groupId: String, senderEventPubkeyHex: String, senderDevicePubkeyHex: String, senderOwnerPubkeyHex: String?, outerEventId: String, outerCreatedAt: UInt64, keyId: UInt32, messageNumber: UInt32, innerEventJson: String, innerEventId: String) {
        self.groupId = groupId
        self.senderEventPubkeyHex = senderEventPubkeyHex
        self.senderDevicePubkeyHex = senderDevicePubkeyHex
        self.senderOwnerPubkeyHex = senderOwnerPubkeyHex
        self.outerEventId = outerEventId
        self.outerCreatedAt = outerCreatedAt
        self.keyId = keyId
        self.messageNumber = messageNumber
        self.innerEventJson = innerEventJson
        self.innerEventId = innerEventId
    }
}



extension GroupDecryptedResult: Equatable, Hashable {
    public static func ==(lhs: GroupDecryptedResult, rhs: GroupDecryptedResult) -> Bool {
        if lhs.groupId != rhs.groupId {
            return false
        }
        if lhs.senderEventPubkeyHex != rhs.senderEventPubkeyHex {
            return false
        }
        if lhs.senderDevicePubkeyHex != rhs.senderDevicePubkeyHex {
            return false
        }
        if lhs.senderOwnerPubkeyHex != rhs.senderOwnerPubkeyHex {
            return false
        }
        if lhs.outerEventId != rhs.outerEventId {
            return false
        }
        if lhs.outerCreatedAt != rhs.outerCreatedAt {
            return false
        }
        if lhs.keyId != rhs.keyId {
            return false
        }
        if lhs.messageNumber != rhs.messageNumber {
            return false
        }
        if lhs.innerEventJson != rhs.innerEventJson {
            return false
        }
        if lhs.innerEventId != rhs.innerEventId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(groupId)
        hasher.combine(senderEventPubkeyHex)
        hasher.combine(senderDevicePubkeyHex)
        hasher.combine(senderOwnerPubkeyHex)
        hasher.combine(outerEventId)
        hasher.combine(outerCreatedAt)
        hasher.combine(keyId)
        hasher.combine(messageNumber)
        hasher.combine(innerEventJson)
        hasher.combine(innerEventId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupDecryptedResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupDecryptedResult {
        return
            try GroupDecryptedResult(
                groupId: FfiConverterString.read(from: &buf), 
                senderEventPubkeyHex: FfiConverterString.read(from: &buf), 
                senderDevicePubkeyHex: FfiConverterString.read(from: &buf), 
                senderOwnerPubkeyHex: FfiConverterOptionString.read(from: &buf), 
                outerEventId: FfiConverterString.read(from: &buf), 
                outerCreatedAt: FfiConverterUInt64.read(from: &buf), 
                keyId: FfiConverterUInt32.read(from: &buf), 
                messageNumber: FfiConverterUInt32.read(from: &buf), 
                innerEventJson: FfiConverterString.read(from: &buf), 
                innerEventId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GroupDecryptedResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.groupId, into: &buf)
        FfiConverterString.write(value.senderEventPubkeyHex, into: &buf)
        FfiConverterString.write(value.senderDevicePubkeyHex, into: &buf)
        FfiConverterOptionString.write(value.senderOwnerPubkeyHex, into: &buf)
        FfiConverterString.write(value.outerEventId, into: &buf)
        FfiConverterUInt64.write(value.outerCreatedAt, into: &buf)
        FfiConverterUInt32.write(value.keyId, into: &buf)
        FfiConverterUInt32.write(value.messageNumber, into: &buf)
        FfiConverterString.write(value.innerEventJson, into: &buf)
        FfiConverterString.write(value.innerEventId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupDecryptedResult_lift(_ buf: RustBuffer) throws -> GroupDecryptedResult {
    return try FfiConverterTypeGroupDecryptedResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupDecryptedResult_lower(_ value: GroupDecryptedResult) -> RustBuffer {
    return FfiConverterTypeGroupDecryptedResult.lower(value)
}


/**
 * Result of sending a group event through GroupManager.
 */
public struct GroupSendResult {
    public var outerEventJson: String
    public var innerEventJson: String
    public var outerEventId: String
    public var innerEventId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outerEventJson: String, innerEventJson: String, outerEventId: String, innerEventId: String) {
        self.outerEventJson = outerEventJson
        self.innerEventJson = innerEventJson
        self.outerEventId = outerEventId
        self.innerEventId = innerEventId
    }
}



extension GroupSendResult: Equatable, Hashable {
    public static func ==(lhs: GroupSendResult, rhs: GroupSendResult) -> Bool {
        if lhs.outerEventJson != rhs.outerEventJson {
            return false
        }
        if lhs.innerEventJson != rhs.innerEventJson {
            return false
        }
        if lhs.outerEventId != rhs.outerEventId {
            return false
        }
        if lhs.innerEventId != rhs.innerEventId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(outerEventJson)
        hasher.combine(innerEventJson)
        hasher.combine(outerEventId)
        hasher.combine(innerEventId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupSendResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupSendResult {
        return
            try GroupSendResult(
                outerEventJson: FfiConverterString.read(from: &buf), 
                innerEventJson: FfiConverterString.read(from: &buf), 
                outerEventId: FfiConverterString.read(from: &buf), 
                innerEventId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GroupSendResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.outerEventJson, into: &buf)
        FfiConverterString.write(value.innerEventJson, into: &buf)
        FfiConverterString.write(value.outerEventId, into: &buf)
        FfiConverterString.write(value.innerEventId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupSendResult_lift(_ buf: RustBuffer) throws -> GroupSendResult {
    return try FfiConverterTypeGroupSendResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupSendResult_lower(_ value: GroupSendResult) -> RustBuffer {
    return FfiConverterTypeGroupSendResult.lower(value)
}


/**
 * Result of accepting an invite.
 */
public struct InviteAcceptResult {
    public var session: SessionHandle
    public var responseEventJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(session: SessionHandle, responseEventJson: String) {
        self.session = session
        self.responseEventJson = responseEventJson
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInviteAcceptResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InviteAcceptResult {
        return
            try InviteAcceptResult(
                session: FfiConverterTypeSessionHandle.read(from: &buf), 
                responseEventJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: InviteAcceptResult, into buf: inout [UInt8]) {
        FfiConverterTypeSessionHandle.write(value.session, into: &buf)
        FfiConverterString.write(value.responseEventJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteAcceptResult_lift(_ buf: RustBuffer) throws -> InviteAcceptResult {
    return try FfiConverterTypeInviteAcceptResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteAcceptResult_lower(_ value: InviteAcceptResult) -> RustBuffer {
    return FfiConverterTypeInviteAcceptResult.lower(value)
}


/**
 * Result of processing an invite response.
 */
public struct InviteProcessResult {
    public var session: SessionHandle
    public var inviteePubkeyHex: String
    public var deviceId: String?
    public var ownerPubkeyHex: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(session: SessionHandle, inviteePubkeyHex: String, deviceId: String?, ownerPubkeyHex: String?) {
        self.session = session
        self.inviteePubkeyHex = inviteePubkeyHex
        self.deviceId = deviceId
        self.ownerPubkeyHex = ownerPubkeyHex
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInviteProcessResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InviteProcessResult {
        return
            try InviteProcessResult(
                session: FfiConverterTypeSessionHandle.read(from: &buf), 
                inviteePubkeyHex: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterOptionString.read(from: &buf), 
                ownerPubkeyHex: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: InviteProcessResult, into buf: inout [UInt8]) {
        FfiConverterTypeSessionHandle.write(value.session, into: &buf)
        FfiConverterString.write(value.inviteePubkeyHex, into: &buf)
        FfiConverterOptionString.write(value.deviceId, into: &buf)
        FfiConverterOptionString.write(value.ownerPubkeyHex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteProcessResult_lift(_ buf: RustBuffer) throws -> InviteProcessResult {
    return try FfiConverterTypeInviteProcessResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteProcessResult_lower(_ value: InviteProcessResult) -> RustBuffer {
    return FfiConverterTypeInviteProcessResult.lower(value)
}


/**
 * Event emitted by SessionManager for external publish/subscribe handling.
 */
public struct PubSubEvent {
    public var kind: String
    public var subid: String?
    public var filterJson: String?
    public var eventJson: String?
    public var senderPubkeyHex: String?
    public var content: String?
    public var eventId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(kind: String, subid: String?, filterJson: String?, eventJson: String?, senderPubkeyHex: String?, content: String?, eventId: String?) {
        self.kind = kind
        self.subid = subid
        self.filterJson = filterJson
        self.eventJson = eventJson
        self.senderPubkeyHex = senderPubkeyHex
        self.content = content
        self.eventId = eventId
    }
}



extension PubSubEvent: Equatable, Hashable {
    public static func ==(lhs: PubSubEvent, rhs: PubSubEvent) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.subid != rhs.subid {
            return false
        }
        if lhs.filterJson != rhs.filterJson {
            return false
        }
        if lhs.eventJson != rhs.eventJson {
            return false
        }
        if lhs.senderPubkeyHex != rhs.senderPubkeyHex {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.eventId != rhs.eventId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(subid)
        hasher.combine(filterJson)
        hasher.combine(eventJson)
        hasher.combine(senderPubkeyHex)
        hasher.combine(content)
        hasher.combine(eventId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePubSubEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PubSubEvent {
        return
            try PubSubEvent(
                kind: FfiConverterString.read(from: &buf), 
                subid: FfiConverterOptionString.read(from: &buf), 
                filterJson: FfiConverterOptionString.read(from: &buf), 
                eventJson: FfiConverterOptionString.read(from: &buf), 
                senderPubkeyHex: FfiConverterOptionString.read(from: &buf), 
                content: FfiConverterOptionString.read(from: &buf), 
                eventId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PubSubEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.kind, into: &buf)
        FfiConverterOptionString.write(value.subid, into: &buf)
        FfiConverterOptionString.write(value.filterJson, into: &buf)
        FfiConverterOptionString.write(value.eventJson, into: &buf)
        FfiConverterOptionString.write(value.senderPubkeyHex, into: &buf)
        FfiConverterOptionString.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.eventId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePubSubEvent_lift(_ buf: RustBuffer) throws -> PubSubEvent {
    return try FfiConverterTypePubSubEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePubSubEvent_lower(_ value: PubSubEvent) -> RustBuffer {
    return FfiConverterTypePubSubEvent.lower(value)
}


/**
 * Result of sending a message.
 */
public struct SendResult {
    public var outerEventJson: String
    public var innerEventJson: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outerEventJson: String, innerEventJson: String) {
        self.outerEventJson = outerEventJson
        self.innerEventJson = innerEventJson
    }
}



extension SendResult: Equatable, Hashable {
    public static func ==(lhs: SendResult, rhs: SendResult) -> Bool {
        if lhs.outerEventJson != rhs.outerEventJson {
            return false
        }
        if lhs.innerEventJson != rhs.innerEventJson {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(outerEventJson)
        hasher.combine(innerEventJson)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendResult {
        return
            try SendResult(
                outerEventJson: FfiConverterString.read(from: &buf), 
                innerEventJson: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SendResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.outerEventJson, into: &buf)
        FfiConverterString.write(value.innerEventJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendResult_lift(_ buf: RustBuffer) throws -> SendResult {
    return try FfiConverterTypeSendResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendResult_lower(_ value: SendResult) -> RustBuffer {
    return FfiConverterTypeSendResult.lower(value)
}


/**
 * Result of sending a text message including stable inner id.
 */
public struct SendTextResult {
    public var innerId: String
    public var outerEventIds: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(innerId: String, outerEventIds: [String]) {
        self.innerId = innerId
        self.outerEventIds = outerEventIds
    }
}



extension SendTextResult: Equatable, Hashable {
    public static func ==(lhs: SendTextResult, rhs: SendTextResult) -> Bool {
        if lhs.innerId != rhs.innerId {
            return false
        }
        if lhs.outerEventIds != rhs.outerEventIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(innerId)
        hasher.combine(outerEventIds)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendTextResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendTextResult {
        return
            try SendTextResult(
                innerId: FfiConverterString.read(from: &buf), 
                outerEventIds: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SendTextResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.innerId, into: &buf)
        FfiConverterSequenceString.write(value.outerEventIds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendTextResult_lift(_ buf: RustBuffer) throws -> SendTextResult {
    return try FfiConverterTypeSendTextResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendTextResult_lower(_ value: SendTextResult) -> RustBuffer {
    return FfiConverterTypeSendTextResult.lower(value)
}


/**
 * Result of accepting an invite through SessionManager.
 */
public struct SessionManagerAcceptInviteResult {
    public var ownerPubkeyHex: String
    public var inviterDevicePubkeyHex: String
    public var deviceId: String
    public var createdNewSession: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ownerPubkeyHex: String, inviterDevicePubkeyHex: String, deviceId: String, createdNewSession: Bool) {
        self.ownerPubkeyHex = ownerPubkeyHex
        self.inviterDevicePubkeyHex = inviterDevicePubkeyHex
        self.deviceId = deviceId
        self.createdNewSession = createdNewSession
    }
}



extension SessionManagerAcceptInviteResult: Equatable, Hashable {
    public static func ==(lhs: SessionManagerAcceptInviteResult, rhs: SessionManagerAcceptInviteResult) -> Bool {
        if lhs.ownerPubkeyHex != rhs.ownerPubkeyHex {
            return false
        }
        if lhs.inviterDevicePubkeyHex != rhs.inviterDevicePubkeyHex {
            return false
        }
        if lhs.deviceId != rhs.deviceId {
            return false
        }
        if lhs.createdNewSession != rhs.createdNewSession {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ownerPubkeyHex)
        hasher.combine(inviterDevicePubkeyHex)
        hasher.combine(deviceId)
        hasher.combine(createdNewSession)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionManagerAcceptInviteResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionManagerAcceptInviteResult {
        return
            try SessionManagerAcceptInviteResult(
                ownerPubkeyHex: FfiConverterString.read(from: &buf), 
                inviterDevicePubkeyHex: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                createdNewSession: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SessionManagerAcceptInviteResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.ownerPubkeyHex, into: &buf)
        FfiConverterString.write(value.inviterDevicePubkeyHex, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterBool.write(value.createdNewSession, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionManagerAcceptInviteResult_lift(_ buf: RustBuffer) throws -> SessionManagerAcceptInviteResult {
    return try FfiConverterTypeSessionManagerAcceptInviteResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionManagerAcceptInviteResult_lower(_ value: SessionManagerAcceptInviteResult) -> RustBuffer {
    return FfiConverterTypeSessionManagerAcceptInviteResult.lower(value)
}


/**
 * FFI-friendly error type.
 */
public enum NdrError {

    
    
    case InvalidKey(String
    )
    case InvalidEvent(String
    )
    case CryptoFailure(String
    )
    case StateMismatch(String
    )
    case Serialization(String
    )
    case InviteError(String
    )
    case SessionNotReady(String
    )
    case AttachmentError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNdrError: FfiConverterRustBuffer {
    typealias SwiftType = NdrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NdrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidKey(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidEvent(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .CryptoFailure(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .StateMismatch(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .InviteError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .SessionNotReady(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .AttachmentError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NdrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidKey(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidEvent(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CryptoFailure(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .StateMismatch(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InviteError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SessionNotReady(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .AttachmentError(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension NdrError: Equatable, Hashable {}

extension NdrError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeGroupDecryptedResult: FfiConverterRustBuffer {
    typealias SwiftType = GroupDecryptedResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGroupDecryptedResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGroupDecryptedResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeInviteProcessResult: FfiConverterRustBuffer {
    typealias SwiftType = InviteProcessResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInviteProcessResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInviteProcessResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiDeviceEntry: FfiConverterRustBuffer {
    typealias SwiftType = [FfiDeviceEntry]

    public static func write(_ value: [FfiDeviceEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiDeviceEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiDeviceEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiDeviceEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiDeviceEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGroupDecryptedResult: FfiConverterRustBuffer {
    typealias SwiftType = [GroupDecryptedResult]

    public static func write(_ value: [GroupDecryptedResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGroupDecryptedResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GroupDecryptedResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [GroupDecryptedResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGroupDecryptedResult.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePubSubEvent: FfiConverterRustBuffer {
    typealias SwiftType = [PubSubEvent]

    public static func write(_ value: [PubSubEvent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePubSubEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PubSubEvent] {
        let len: Int32 = try readInt(&buf)
        var seq = [PubSubEvent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePubSubEvent.read(from: &buf))
        }
        return seq
    }
}
/**
 * Create a signed AppKeys event JSON for publishing to relays.
 */
public func createSignedAppKeysEvent(ownerPubkeyHex: String, ownerPrivkeyHex: String, devices: [FfiDeviceEntry])throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_create_signed_app_keys_event(
        FfiConverterString.lower(ownerPubkeyHex),
        FfiConverterString.lower(ownerPrivkeyHex),
        FfiConverterSequenceTypeFfiDeviceEntry.lower(devices),$0
    )
})
}
/**
 * Derive a public key from a hex-encoded private key.
 */
public func derivePublicKey(privkeyHex: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_derive_public_key(
        FfiConverterString.lower(privkeyHex),$0
    )
})
}
/**
 * Generate a new keypair.
 */
public func generateKeypair() -> FfiKeyPair {
    return try!  FfiConverterTypeFfiKeyPair.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_func_generate_keypair($0
    )
})
}
/**
 * Download and decrypt an attachment into memory (for inline media rendering).
 */
public func hashtreeDownloadBytes(nhash: String, readServers: [String])throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_hashtree_download_bytes(
        FfiConverterString.lower(nhash),
        FfiConverterSequenceString.lower(readServers),$0
    )
})
}
/**
 * Download and decrypt an attachment directly to disk via streaming IO.
 */
public func hashtreeDownloadToFile(nhash: String, outputPath: String, readServers: [String])throws  {try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_hashtree_download_to_file(
        FfiConverterString.lower(nhash),
        FfiConverterString.lower(outputPath),
        FfiConverterSequenceString.lower(readServers),$0
    )
}
}
/**
 * Compute an `nhash1...` identifier for a local file without uploading.
 */
public func hashtreeNhashFromFile(filePath: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_hashtree_nhash_from_file(
        FfiConverterString.lower(filePath),$0
    )
})
}
/**
 * Upload a file via hashtree/Blossom and return its deterministic `nhash1...`.
 */
public func hashtreeUploadFile(privkeyHex: String, filePath: String, readServers: [String], writeServers: [String])throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_hashtree_upload_file(
        FfiConverterString.lower(privkeyHex),
        FfiConverterString.lower(filePath),
        FfiConverterSequenceString.lower(readServers),
        FfiConverterSequenceString.lower(writeServers),$0
    )
})
}
/**
 * Parse an AppKeys event JSON and return the contained device entries.
 */
public func parseAppKeysEvent(eventJson: String)throws  -> [FfiDeviceEntry] {
    return try  FfiConverterSequenceTypeFfiDeviceEntry.lift(try rustCallWithError(FfiConverterTypeNdrError.lift) {
    uniffi_ndr_ffi_fn_func_parse_app_keys_event(
        FfiConverterString.lower(eventJson),$0
    )
})
}
/**
 * Returns the version of the ndr-ffi crate.
 */
public func version() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ndr_ffi_fn_func_version($0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_ndr_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_create_signed_app_keys_event() != 62391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_derive_public_key() != 23373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_generate_keypair() != 56100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_hashtree_download_bytes() != 4843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_hashtree_download_to_file() != 602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_hashtree_nhash_from_file() != 19710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_hashtree_upload_file() != 31044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_parse_app_keys_event() != 33390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_func_version() != 58200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_accept() != 50404) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_accept_with_owner() != 19609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_get_inviter_pubkey_hex() != 17047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_get_shared_secret_hex() != 42269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_process_response() != 8323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_serialize() != 6090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_set_owner_pubkey_hex() != 988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_set_purpose() != 14438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_to_event_json() != 25504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_invitehandle_to_url() != 21533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionhandle_can_send() != 64471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionhandle_decrypt_event() != 61795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionhandle_is_dr_message() != 39495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionhandle_send_text() != 53814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionhandle_state_json() != 62261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_accept_invite_from_event_json() != 10447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_accept_invite_from_url() != 1488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_drain_events() != 33023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_get_active_session_state() != 34884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_get_device_id() != 27863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_get_our_pubkey_hex() != 15248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_get_owner_pubkey_hex() != 38134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_get_total_sessions() != 54736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_group_handle_incoming_session_event() != 45714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_group_handle_outer_event() != 9485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_group_known_sender_event_pubkeys() != 34048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_group_remove() != 33157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_group_send_event() != 4165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_group_upsert() != 12505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_import_session_state() != 57446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_init() != 12215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_process_event() != 55445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_send_event_with_inner_id() != 35167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_send_reaction() != 32190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_send_receipt() != 34112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_send_text() != 39171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_send_text_with_inner_id() != 49408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_method_sessionmanagerhandle_send_typing() != 11765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_invitehandle_create_new() != 4301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_invitehandle_deserialize() != 552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_invitehandle_from_event_json() != 46752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_invitehandle_from_url() != 7682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_sessionhandle_from_state_json() != 2882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_sessionhandle_init() != 28461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_sessionmanagerhandle_new() != 8939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ndr_ffi_checksum_constructor_sessionmanagerhandle_new_with_storage_path() != 33050) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all